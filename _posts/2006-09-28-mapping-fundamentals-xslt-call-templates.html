---
title: "Mapping Fundamentals - XSLT Call Templates"
layout: post
---
<p>I'm creating a new series of posts related to using the BizTalk Mapper.&nbsp; I know, it's certainly less sexy than Pipeline Testing Framework (seriously, follow that link) or many other BizTalk subjects, but so much of the magic of BizTalk happens in the mapping.</p> <p>In my experience, when people are introduced to the BizTalk Mapper they get it very quickly.&nbsp; The user interface is straight forward for <strong>most</strong> of what you need to do in mapping output.&nbsp; But certainly not all.&nbsp; Take for example some data that looks like this :</p> <p> <p> <p>&lt;?xml version="1.0" encoding="utf-8" ?&gt; <p>&lt;MyRoot&gt; <p>&nbsp; &lt;ref qualifier="D2" value="999999999" /&gt; <p>&nbsp; &lt;ref qualifier="XX" value="999999999" /&gt; <p>&nbsp; &lt;ref qualifier="ZZ" value="XX-YYYYYYYY" /&gt; <p>&nbsp; &lt;nm qualifier="NI" value="999999999" /&gt; <p>&lt;/MyRoot&gt; <p> <p>&nbsp;</p> <p>Your mission, should you choose to accept it is simple.&nbsp; Output one and only one value to destination schema in a node called Identifier which contains either the value of the 'value' attribute of the 'nm' element if the matching qualifier is 'ZZ' or if that does not exist the 'value' attribute&nbsp;of any 'ref' element containing a 'qualifier' attribute of 'ZZ'.&nbsp; If neither exists, then output the constant value 'N/A'.</p> <p>The catch?&nbsp; Both nodes <strong>can</strong> both exist with the proper qualifier, and 'nm' must take precedence in that case.</p> <p>Now, I've no doubt at all that someone could come up with some combination of functoids which might solve this problem.&nbsp; But we must remember that in the end a map is just XSLT and this problem is supremely easy in XSLT and extremely difficult with the mapper.&nbsp; The solution, as you've likely already guessed, is an XSLT Call Template Scripting Functoid.</p> <p>An XSLT Call Template Scripting Functoid lets you inject your own XSLT into the middle of a map.&nbsp; No need to take the effort of writing the full XSLT yourself if only one or two mappings are giving you trouble.&nbsp; Obviously to be able to write such a functoid you need to understand XSLT, which if you are mapping is a good skill to have anyway.&nbsp; In this simple example we don't even have to deal with parameters.&nbsp; By entering a template as follows, you can solve this problem in a few short lines.</p> <p>&nbsp; &lt;xsl:template name="MapIdentifier"&gt; <p>&nbsp; &nbsp; &lt;xsl:variable name="nmValue" select="/MyRoot/nm[@qualifier='ZZ']/@value" /&gt; <p>&nbsp; &nbsp; &lt;xsl:variable name="refValue" select="/MyRoot/ref[@qualifier='ZZ']/@value" /&gt; <p>&nbsp; &nbsp; &lt;xsl:element name="Identifier"&gt; <p>&nbsp; &nbsp; &nbsp; &lt;xsl:choose&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:when test="$nmValue"&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:value-of select="$nmValue"/&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;/xsl:when&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:when test="$refValue"&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:value-of select="$refValue"/&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;/xsl:when&gt; <p>&nbsp; &nbsp; &nbsp; &nbsp; &lt;xsl:otherwise&gt;N/A&lt;/xsl:otherwise&gt; <p>&nbsp; &nbsp; &nbsp; &lt;/xsl:choose&gt; <p>&nbsp; &nbsp; &lt;/xsl:element&gt; <p>&nbsp; &lt;/xsl:template&gt; <p>&nbsp; <p>Some things to remember when working with XSLT Call Templates. <ol> <li>Only use these when needed.&nbsp; I recently heard Roy Osherove give the same advice regarding Regular Expression and he was right.&nbsp; Both RegEx and XSLT Call Templates are more cryptic and harder for someone coming after you to decipher.&nbsp; Use them when you must, when they save you time, but don't lean on them for everything.</li> <li>The Template name must be unique within the map.&nbsp; If you copy-paste the template and don't change the name then only one version will be run.&nbsp; If you later modify one of them and start going nuts trying to figure out why the second isn't behaving properly, check your names.</li> <li>XSLT Call Templates must create the destination node.&nbsp; Element or Attribute they don't care, when you write one of these you are taking on the job of outputting that node, namespace and all.&nbsp;</li></ol> <p>I hope this has been a good quick primer on using XSLT Call Templates.&nbsp; If you've got a topic you'd like covered, leave a comment!</p> <p><em>[Post Script : Before anyone comments, the example XML given was deliberately rendered similar to an EDI structure because this is a common problem in EDI mappings.]</em></p>
